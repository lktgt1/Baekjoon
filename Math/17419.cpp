// 백준 17419

// K = K-(K&((~K)+1))을 연산 우선순위대로 따라가 보면
// 1. ~K : K의 비트 반전이다. 0은 1이 되고, 1은 0이 된다.
// 2. +1 : 반전시킨 비트에 1을 더한다. 최하위 비트부터 1을 Carry한다.
// 3. K& : 앞서 연산한 비트와 AND연산을 한다. 여기까지 연산한 결과는 원래 K의 비트 중
// 1을 가진 최하위 비트 자리만 1로 남게 된다.

// 4. K- : 앞서 연산한 결과가 원래 K 비트중 최하위 1을 가리키는 비트를 빼기 때문에 최종 결과는
// K의 비트 중 최하위 1의 비트만 사라진게 된다.

// 결국 연산 한번당 최하위 1의 비트가 사라지기 때문에 연산횟수는 1의 갯수가 된다.

#include <iostream>
#include <string>
using namespace std;

int main(){
	int n,ans = 0;
	string s;
	cin >> n >> s;
	for(char c : s) if(c=='1') ans++;
	cout << ans;
}